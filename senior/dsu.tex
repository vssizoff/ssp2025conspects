\section{Система непересекающихся множеств}

\begin{problem}
    Дан неориентированный граф. По двум вершинам нужно понимать, находятся ли они в одной компоненте связности. Имеется два типа запросов:
    \begin{enumerate}[nolistsep]
        \item Объединение --- построить ребро между двумя вершинами;
        \item Связность --- по двум вершинам проверить, находятся ли они в одной компоненте.
    \end{enumerate}
\end{problem}

Наивное решение (с помощью обхода в ширину) имеет асимптотическую сложность $O((n + m) \cdot q)$. Это не будет проходить по времени при вполне разумных ограничениях по типу $n, q \leqslant 10^5$.

Ещё можно пробовать красить компоненты в отдельные цвета. Проблема в том, что тогда при объединении двух компонент, нужно хотя бы одну из них полностью перекрасить (в другой цвет), и каждое обновление будет происходить за $O(n)$.

\subsection{Основная идея}

Для каждой компоненты связности создаём ориентированное остовное дерево, в котором каждое ребро направлено от листьев к корню. Тогда для любых двух вершин будем подниматься до корней, и если они совпали, то они находятся в одном множестве; иначе --- нет.

Для оптимизации при подвешивании деревьев друг к другу (объединении множеств) будем делать так: корень меньшего дерева будем подвешивать к корню большего. Тогда мы будем получать самые низкие деревья, чтобы меньше по ним ходить.

\begin{theorem}
    Высота каждого дерева растёт как $O(\log n)$.
\end{theorem}

\begin{proof}
    Проведём индукцию по размеру деревьев $v$.
    
    \textbf{База} ($v = 1$). На графе без рёбер размер деревьев равен $1 = \log_20$.

    \textbf{Шаг} ($v = v_1 + v_2$). Пусть имеем два дерева с $v_1$ и $v_2$ вершинами соответственно. Не ограничивая общности, считаем, что $v_1 \leqslant v_2$. Обозначим через $h_1$ и $h_2$ высоты соответствующих деревьев, а через $h_{1 \cup 2}$ обозначим высоту объединения деревьев. По предположению индукции $h_i \leqslant \lceil\log_2v_i\rceil$ ($i = 1, 2$). Рассмотрим два случая:
    \begin{enumerate}[nolistsep]
        \item $h_1 \ne h_2$. Тогда $h_{1 \cup 2} = \max\{h_1, h_2\}$. Отсюда,
        \[
            h_{1 \cup 2} = \max\{h_1, h_2\} \leqslant \max\{\lceil\log_2v_1\rceil, \lceil\log_2v_2\rceil\} \leqslant \lceil\log_2(v_1 + v_2)\rceil,
        \]
        где последнее неравенство выполнено в силу монотонности функции логарифма.
        \item $h_1 = h_2$ ($= \vcentcolon h$). Тогда $h_{1 \cup 2} = h + 1$, причём по предположению индукции $h \leqslant \min\{\lceil\log_2v_1\rceil, \lceil\log_2v_2\rceil\} = \lceil\log_2v_1\rceil$ (опять же в силу монотонности). Теперь
        \[
            h_{1 \cup 2} = h + 1 \leqslant \lceil\log_2v_1\rceil + 1 = \lceil\log_2(2 \cdot v_1)\rceil \leqslant \lceil\log_2(v_1 + v_2)\rceil.
        \]
    \end{enumerate}
    Таким образом, высота любого дерева в СНМ есть $O(\log n)$.
\end{proof}

\begin{corollary}
    Время выполнения одной операции в СНМ есть $O(\log n)$.
\end{corollary}

\begin{proof}
    Для проверки мы поднимаемся от вершин к их корням, делая не более $2\log_2n = O(\log n)$ шагов.
\end{proof}

\subsection{Реализация}

\begin{minted}[linenos, mathescape]{cpp}
vector<int> link; // ссылка на корень, по умолчанию храним $-1$
vector<int> h_set; // высота поддерева вершины, сначала равна $0$

// По вершине находит корень её дерева
int find(int v)
{
    if (link[v] == -1)
        return v;
    return find(link[v]);
}

// По $2$-м вершинам объединяет деревья, в которых они находятся
void unite(int u, int v)
{
    u = find(u), v = find(v);

    if (u == v) return;

    if (h_set[u] > h_set[v])
        swap(u, v);

    link[u] = v;
    h_set[v] += (h_set[u] == h_set[v]);
}

bool check(int u, int v)
{
    u = find(u), v = find(v);

    return u == v;
}
\end{minted}

Как уже было доказано выше, каждая операция в СНМ работает за $O(\log n)$. Этот алгоритм можно ещё улучшить. Если имеем поддерево $i \hm \ot j \ot k$, то можно его переподвесить $i \ot k$. Для этого в функции \texttt{find} нахождения корня вместо \mintinline{cpp}{return find(link[v]);} нужно писать \mintinline{cpp}{return (link[v] = find(link[v]));}, тогда все вершины переподвешиваются к одному корню. Однако так нельзя делать в задачах, где нужно помнить, в какие моменты времени мы объединяли деревья, т.\,к. при таком подходе эта информация теряется.

Асимптотика такого решения составляет $O(\alpha(n, m))$ ($n$ --- число вершин в графе, $m$ --- число запросов), где $\alpha$ --- обратная функция Аккермана. Отметим, что при любых значениях $n$ и $m$, возникающих в прикладных задачах, $\alpha(n, m) \leqslant 4$, так что можно считать, что функция \texttt{find} выполняется за константное время.

\subsection{Поиск минимального остова}

\begin{definition}
    \textit{Остовом} графа называется поддерево, содержащее все его вершины. \textit{Минимальным остовом} ориентированного графа называется его остов с минимальным суммарным весом рёбер.
\end{definition}

\begin{algorithm}[Краскала]
    Заведём список рёбер графа $G$, отсортируем его по увеличению веса и будем идти по этому списку.  Для каждого ребра посмотрим, находятся ли его вершины в одном множестве. Если нет --- связываем эти множества (проводим ребро в остове). Асимптотика составляет $O(m\log m + m\alpha(n, m))$.
\end{algorithm}
