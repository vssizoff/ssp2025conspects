\section{Перебор и динамика по подотрезкам, поддеревьям,
подмножествам, подмаскам, \ldots}

%\subsection{Линейная динамика}

%Напомним, что мы называем \textit{линейным динамическим программированием} и рассмотрим пример задачи, которую оно решает.

%\begin{problem}
%    Есть дорожка из $n$ клеток (нумеруем с $0$), Марио стоит в нулевой. Известно, что некоторые клетки залиты лавой, на них наступать нельзя. Они указаны в массиве отметок $\{a_0, a_1, \ldots, a_{n - 1}\}$ ($a_i = 1$, если $i$-я клетка залита лавой, иначе $a_i = 0$). Марио умеет прыгать на одну или две клетки вперёд. Сколькими способами он может попасть из нулевой клетки в $(n - 1)$-ю?
%\end{problem}

%Пусть $d_i$ --- число способов попасть из нулевой клетки в $i$-ю ($0 \leqslant i \hm < n$). В качестве базы возьмём $d_0 = 1$ (попасть из нулевой клетки в себя можно только одним способом --- пустым путём) и $d_1 = 1 - a_1$. Здесь мы учитываем, что клетка с номером $1$ может быть залита лавой. Тогда имеем рекуррентную формулу
%\[
%    d_i = (1 - a_{i - 1}) \cdot d_{i - 1} + (1 - a_{i - 2}) \cdot d_{i - 2}.
%\]

%Результат хранится в $d_{n - 1}$, и его вычисление заняло $O(n)$ времени.

\subsection{Динамика по подотрезкам}

\begin{problem}
    Дана строка $s$ длины $n$. Найти количество её подстрок, являющихся палиндромами.
\end{problem}

Заведём двумерный массив $d$ размера $(n + 1) \times (n + 1)$; пусть $d_{l, r} = 1$, если подстрока $[s_l\ldots s_r)$ является палиндромом, иначе $d_{l, r} = 0$. Тогда условия $d_{i, i} = 1$ ($0 \leqslant i \leqslant n$) и $d_{i, i + 1} = 1$ ($0 \leqslant i < n$) можно взять за базу (все подстроки длины $0$ и $1$ являются палиндромами). Тогда при $r > l + 1$ имеем
\[
    d_{l, r} =
    \begin{cases}
        1,&\text{если $s_l = s_{r - 1}$ и $d_{l + 1, r - 1} = 1$},\\
        0,&\text{иначе}.
    \end{cases}
\]

Можем вести цикл по левым границам и длинам отрезков, заполняя наш массив за $O(n^2)$ по указанной формуле.

\subsection{Динамика по поддеревьям}

\begin{problem}
    Дано дерево $G$. Найти сумму всех путей в нём.
\end{problem}
%
Наивное решение: перебираем вершины и любым обходом ищем путь из неё во все остальные. Асимптотика составляет $O(n \cdot (n + m))$, где $m \hm = n - 1$ (т.\,к. $G$ --- дерево), т.\,е. $O(n^2)$.

Подвесим дерево за какую-то вершину. Обозначим через $d_v$ число вершин в~поддереве $v$. Тогда число путей, содержащих ребро $(u, v)$ (где $v$ --- непосредственный сын $u$ при подвешивании) равно $d_v \cdot (n \hm - d_v)$. Тогда ответом будет
\[
    \sum\limits_{(u, v) \in E}d_v \cdot (n - d_v).
\]

\begin{minted}[linenos, mathescape]{cpp}
vector<vector<int>> adj; // список смежности дерева $G$
vector<int> d(n, 1); // пока в поддереве $u$ одна вершина - $u$
vector<int> p; // храним предков
vector<int> cnt_sons; // храним число сыновей

queue<int> q;
q.push(0);
while (!q.empty())
{
    int u = q.front(); q.pop();
    for (int v : adj[u])
        if (v != p[u])
        {
            p[v] = u;
            ++cnt_sons[u];
            q.push(v);
        }
}

for (int u = 0; u < n; ++u)
    if (!cnt_sons[u]) // тогда $u$ - лист
        q.push(u);

int ans = 0;
while (!q.empty())
{
    int v = q.front(); q.pop();
    u = p[v];
    ans += d[v] * (n - d[v]);
    d[u] += d[v];
    if (!(--cnt_sons[u]))
        q.push(u);
}
\end{minted}

\subsection{Динамика по подмножествам или подмаскам}

\begin{definition}
    Путь в графе $G$ называется \textit{гамильтоновым}, если он проходит через все вершины ровно по одному разу.
\end{definition}

\begin{problem}
    В данном взвешенном графе $G$ найти минимальный по весу гамильтонов путь (если он существует).
\end{problem}

Обозначим через $w_{u, v}$ вес ребра $(u, v)$ (удобно считать $w_{u, v} = +\infty$, если ребра $(u, v)$ не существует). Пусть $d_{\{v_0, v_1, \ldots, v_{k - 1}\}, v_j}$ ($0 \leqslant j < k$) хранит вес минимального гамильтонова пути, проходящего через все вершины $\{v_0, v_1, \ldots, v_{k - 1}\}$, оканчивающегося в вершине $v_j$.

Тогда база выглядит как $d_{\{u\}, u} = 0$ для всех $u$, а рекуррентная формула имеет вид
\begin{multline*}
    d_{\{v_0, v_1, \ldots, v_{k - 1}\}, v_j} = \min\{d_{\{v_0, v_1, \ldots, \widehat{v_j}, \ldots, v_{k - 1}\}, v_0} + w_{v_j, v_0},\\ d_{\{v_0, v_1, \ldots, \widehat{v_j}, \ldots, v_{k - 1}\}, v_1} + w_{v_j, v_1}, \ldots, d_{\{v_0, v_1, \ldots, \widehat{v_j}, \ldots, v_{k - 1}\}, v_{j - 1}} + w_{v_j, v_{j - 1}},\\ d_{\{v_0, v_1, \ldots, \widehat{v_j}, \ldots, v_{k - 1}\}, v_{j + 1}} + w_{v_j, v_{j + 1}}, \ldots, d_{\{v_0, v_1, \ldots, \widehat{v_j}, \ldots, v_{k - 1}\}, v_{k - 1}} + w_{v_j, v_{k - 1}}\}
\end{multline*}

Перебор подмножеств будем реализовывать с помощью \textit{масок}. Идея в том, что любое подмножество $\mathcal{S} \subseteq \mathcal{M} \vcentcolon = \{0, 1, \ldots, n - 1\}$ мощности $n$ задаётся битовым числом $b(\mathcal{S}) \vcentcolon = \overline{b_{n - 1}\ldots b_1b_0}$, где
\[
    b_i =
    \begin{cases}
        1,&\text{если $i \in \mathcal{S}$},\\
        0,&\text{иначе}.
    \end{cases}
\]

\begin{minted}[linenos, mathescape]{cpp}
for (unsigned int mask = 1; mask < (1 << n); ++mask)
{
    for (int i = 0; i < n; ++i)
    {
        if (mask & (1 << i)) // содержит ли $i$-й элемент
        {
            if (mask == (1 << i))
                d[mask][i] = 0;
            else
            {
                for (int j = 0; j < n; ++j)
                    if (j != i && mask & (1 << j))
                        d[mask][i] = min(d[mask][i],
                        d[mask ^ (1 << j)][j] + w[i][j]);
            }
        }
    }
}
\end{minted}

Асимптотика этого алгоритма есть $O(2^n \cdot n^2)$, так что укладываться в~одну секунду он будет (примерно) лишь на $n \leqslant 18$.
