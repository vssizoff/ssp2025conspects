\section{Мосты, точки сочленения, компоненты сильной связности}

\subsection{Мосты}

\begin{definition}
    \textit{Мостом} называется ребро, при удалении которого число компонент связности неориентированного графа увеличивается.
\end{definition}

Далее мы рассматриваем граф как одну компоненту связности и ищем мосты внутри неё.

Запустим обход в глубину из произвольной вершины. Введём новые виды рёбер:
\begin{enumerate}[nolistsep]
    \item \textit{Прямые} --- те, по которым были переходы;
    \item \textit{Обратные} --- все остальные.
\end{enumerate}

Заметим, что никакое обратное ребро $(u, v)$ не может являться мостом: если его удалить, то всё равно будет существовать какой-то путь от $u$ до $v$, потому что подграф из прямых рёбер является связным деревом.

Значит, остаётся проверить только все прямые рёбра. Заметим, что обратные рёбра могут вести только <<вверх>> --- к какому-то предку в дереве обхода графа, но не в другие <<ветки>>, ведь иначе наш обход увидел бы это ребро раньше, и оно было бы прямым.

Тогда, чтобы определить, является ли прямое ребро $v \to u$ мостом, мы можем воспользоваться следующим критерием: глубина $h_v$ вершины $v$ меньше, чем минимальная глубина всех вершин, соединённых обратным ребром с какой-либо вершиной из поддерева $u$.

Для ясности, обозначим эту величину как $d_u$, её можно считать во время обхода по следующей формуле:

\[
    d_v = \min
    \begin{cases}
        h_v,&\\
        d_u,&\text{ребро $v \to u$ прямое},\\
        h_u,&\text{ребро $v \to u$ обратное}.
    \end{cases}
\]

Если это условие ($h_v < d_u$) не выполняется, то существует какой-то путь из $u$ в какого-то предка $v$ или саму $v$, не использующий ребро $(v, u)$, а в противном случае --- наоборот.

\begin{minted}[linenos, mathescape]{cpp}
vector<int> used, h, d;

void dfs(int v, int p = -1)
{
    used[v] = 1;
    d[v] = h[v] = (p == -1 ? 0 : h[p] + 1);
    for (int u : adj[v])
    {
        if (u != p)
        {
            if (used[u]) // если ребро обратное
                d[v] = min(d[v], h[u]);
            else // если ребро прямое
            {
                dfs(u, v);
                d[v] = min(d[v], d[u]);
                if (h[v] < d[u])
                {
                    // Если нельзя другим путём добраться
                    // в $v$ или выше, то ребро $(v, u)$ - мост
                }
            }
        }
    }
}
\end{minted}

\subsection{Точки сочленения}

\begin{definition}
    \textit{Точкой сочленения} называется вершина, при удалении которой число компонент связности неориентированного графа увеличивается.
\end{definition}

Задача поиска точек сочленения не сильно отличается от задачи поиска мостов.

Вершина $v$ является точкой сочленения, когда из какого-то её сына $u$ нельзя дойти до её предка, не используя ребро $(v, u)$. Для конкретного прямого ребра $v \to u$ этот факт можно проверить так: $h_v \leqslant d_u$ (теперь неравенство нестрогое, т.\,к. если из вершины можно добраться только неё самой, то она всё равно будет точкой сочленения).

Используя этот факт, можно оставить алгоритм практически прежним --- нужно проверить этот критерий для всех прямых рёбер $v \to u$.

\begin{minted}[linenos, mathescape]{cpp}
void dfs(int v, int p = -1)
{
    used[v] = 1;
    d[v] = h[v] = (p == -1 ? 0 : h[p] + 1);
    int children = 0;
    for (int u : adj[v])
    {
        if (u != p)
        {
            if (used[u])
                d[v] = min(d[v], h[u]);
            else
            {
                dfs(u, v);
                d[v] = min(d[v], d[u]);
                if (h[v] <= d[u] && p == -1)
                {
                    // $v$ - точка сочленения
                    // (это условие может выполняться
                    // много раз для разных детей)
                }
                ++children;
            }
        }
    }
    // Корень смотрим отдельно
    if (p == -1 && children > 1)
    {
        // $v$ - корень и точка сочленения
    }
}
\end{minted}

Единственный крайний случай --- это корень, т.\,к. в него мы войдём раньше других вершин. Поправить просто --- достаточно посмотреть, было ли у него более одной ветви в обходе (если корень удалить, то его поддеревья станут несвязными между собой).

\subsection{Топологическая сортировка}

\begin{problem}
    Дан ориентированный ациклический граф. Требуется найти такой порядок вершин, в котором все рёбра графа вели из более ранней вершины в более позднюю.
\end{problem}

Во-первых, заметим, что граф с циклом топологически отсортировать не получится --- как ни располагай цикл в массиве, всё время идти вправо по рёбрам цикла не получится. Во-вторых, верно обратное --- если цикла нет, то его обязательно можно топологически отсортировать.

\begin{lemma}
    В ориентированном графе либо есть цикл, либо вершина без выходящих рёбер.
\end{lemma}

\begin{proof}
    Выберем произвольную вершину и начнём с неёол переходить по рёбрам графа. Либо этот процесс когда-нибудь закончится (если когда-нибудь попадём в вершину без выходящих рёбер), либо будет продолжаться бесконечно (но тогда, в силу конечности числа вершин в графе, попадём в какую-то вершину дважды).
\end{proof}

Заметим, что вершину, из которой не ведёт ни одно ребро, можно всегда поставить последней, а такая вершина в ациклическом графе всегда есть. Из этого сразу следует конструктивное доказательство: будем итеративно класть в массив вершину, из которой ничего не ведёт, и убирать её из графа. Новых циклов при этом, очевидно, не появится, так что в новом графе опять найдётся вершина без выходящих рёбер. После этого процесса массив надо будет развернуть.

Этот алгоритм проще реализовать, обратив внимание на времена выхода вершин в поиске в глубину. Вершина, из которой мы выйдем первой --- та, у которой нет новых исходящих рёбер. Дальше мы будем выходить только из тех вершин, которые если и имеют исходящие рёбра, то только в те вершины, из которых мы уже вышли.

Следовательно, достаточно просто выписать вершины в порядке выхода из обхода в глубину, а затем полученный список развернуть, и мы получим одну из корректных топологических сортировок.

\begin{minted}[linenos, mathescape]{cpp}
vector<vector<int>> adj;
vector<int> used, t;

void dfs(int u)
{
    used[u] = 1;
    for (int v : adj[u])
        if (!used[v])
            dfs(v);
    t.push_back(u);
}

void top_sort()
{
    for (int u = 0; u < n; ++u)
        if (!used[u])
            dfs(u);
    reverse(t.begin(), t.end());
}
\end{minted}

Топологическую сортировку можно использовать для проверки достижимости, сравнивая номера вершин в получившемся массиве. Факт того, что вершина $a$ идёт позже вершины $b$, говорит о том, что из $a$ недостижима $b$ --- однако $a$ может быть как достижима, так и недостижима из $b$.

\subsection{Компоненты сильной связности}

Мы научились топологически сортировать ациклические графы. Но в циклических графах тоже иногда требуется найти какую-то структуру, для чего нам нужно ввести следующее понятие.

\begin{definition}
    Две вершины ориентированного графа \textit{сильно связны}, если существует путь из одной в другую, и наоборот. Иными словами, они обе лежат в каком-то цикле.
\end{definition}

\begin{statement}
    Отношение сильной связности является отношением эквивалентности.
\end{statement}

\begin{proof}
    Рефлексивность и симметричность очевидны из определения, проверим транзитивность. Пусть $a$ и $b$ сильно связны, и $b$ и $c$ сильно связны. Тогда можно дойти из $a$ в $b$, а из $b$дойти в $c$, и наоборот. Так что вершины $a$ и $c$ тоже сильно связны.
\end{proof}

\begin{definition}
    Классы этой эквивалентности называются \textit{компонентами сильной связности}.
\end{definition}

Самый простой пример сильно-связной компоненты --- это цикл. Но это может быть и полный граф, или сложное пересечение нескольких циклов.

Часто рассматривают граф, составленный из самих компонент сильной связности, а не индивидуальных вершин. Очевидно, такой граф уже будет ациклическим, с ним проще работать. Задачу о сжатии каждой компоненты сильной связности в одну вершину называют \textit{конденсацией} графа, и её решение мы сейчас опишем.

\subsection{Конденсация графа}

Если мы уже знаем, какие вершины лежат в каждой компоненте сильной связности, то построить граф конденсации несложно: нужно провести некоторые манипуляции со списками смежности, заменив для всех рёбер номера вершин номерами их компонент, а затем объединив списки смежности для всех вершин каждой компоненты. Поэтому сразу сведём исходную задачу к нахождении самих компонент.

\begin{lemma}
    Запустим обход в глубину. Пусть $A$ и $B$ --- две различные компоненты сильной связности, и пусть в графе конденсации между ними есть ребро $A \to B$. Тогда $\max\limits_{a \in A}\mathrm{tout}_a > \max\limits_{b \in B}\mathrm{tout}_b$.
\end{lemma}

\begin{proof}
    Рассмотрим два случая, в зависимости от того, в какую из компонент обход зайдёт первым:
    \begin{enumerate}[nolistsep]
        \item Пусть первой была достигнута компонента $A$, т.\,е. в какой-то момент времени DFS заходит в некоторую вершину $v$ компоненты $A$, и при этом все остальные вершины компонент $A$ и $B$ ещё не посещены. Но т.\,к. по условию в графе конденсаций есть ребро $A \to B$, то из вершины $v$ будет достижима не только вся компонента $A$, но и вся компонента $B$. Это означает, что при запуске из вершины $v$ обход в глубину пройдёт по всем вершинам компонент $A$ и $B$, а значит, они станут потомками по отношению к $v$ в дереве обхода, и для любой вершины $u \in A \sqcup B$, $u \ne v$ будет выполнено $\mathrm{tout}_v > \mathrm{tout}_u$, что и требовалось.
        \item Второй случай проще: из $B$ по условию нельзя дойти до $A$, а значит, если первой была достигнута $B$, то DFS выйдет из всех её вершин ещё до того, как войти в $A$.
    \end{enumerate}
\end{proof}

Из этого факта следует первая часть решения. Отсортируем вершины по убыванию времени выхода (т.\,е. как бы сделаем топологическую сортировку, но на циклическом графе). Рассмотрим компоненту сильной связности первой вершины в сортировке. В эту компоненту точно не входят никакие рёбра из других компонент --- иначе нарушилось бы условие леммы, ведь у первой вершины $\mathrm{tout}$ максимальный. Поэтому, если развернуть все рёбра в графе, то из этой вершины будет достижима свой компонента сильной связности $C$, и больше ничего --- если в исходном графе не было рёбер из других компонент, то в развёрнутом графе не будет рёбер в другие компоненты.

После того, как мы сделали это с первой вершины, мы можем пойти по топологически отсортированному списку дальше и то же самое с вершинами, для которых компоненту связности мы ещё не отметили.

\begin{minted}[linenos, mathescape]{cpp}
vector<vector<int>> adj, t;
vector<int> order, used, comp;
int cnt_comps = 0;

// Топологическая сортировка
void dfs1(int u)
{
    used[u] = 1;
    for (int v : adj[u])
        if (!used[v])
            dfs1(v);
    order.push_back(u);
}

void dfs2(int u)
{
    comp[u] = cnt_comps;
    for (int v : t[u])
        if (!comp[v])
            dfs2(v);
}

// ... 
// В содержательной части main:

// Разворачиваем граф
for (int u = 0; u < n; ++u)
    for (int v : adj[u])
        t[v].push_back(u);

// Запускаем топологическую сортировку
for (int i = 0; i < n; ++i)
    if (!used[i]) dfs1(i);

// Выделяем компоненты
reverse(order.begin(), order.end());
for (int u : order)
    if (!comp[u])
        dfs2(u), ++cnt_comps;
\end{minted}

