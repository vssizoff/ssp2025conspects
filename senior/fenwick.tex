\section{Дерево Фенвика, разреженная таблица}

\subsection{Дерево Фенвика}

Дерево Фенвика --- структура данных, которая на многих задачах заменяет собой дерево отрезков, но при этом работает в $3$-$4$ раза быстрее, занимает минимально возможное количество памяти (столько же, сколько и массив той же длины), намного быстрее пишется и легче обобщается на большие размерности.

\subsubsection{Основная идея}

\begin{definition}
    Пусть дан массив $\{a_0, a_1, \ldots, a_{n - 1}\}$. \textit{Деревом Фенвика} будем называть массив $t$ той же длины, объявленный следующим образом:
    \[
        t_i = \sum_{j = F(i)}^{i}a_j,
    \]
    где $F$ --- какая-то функция, для которой выполнено $F(i) \leqslant i$ для каждого $i$.
\end{definition}

Предположим, нам нужно эффективно отвечать на запросы суммы на отрезках и обновления $i$-го элемента.

Когда нам нужна сумма на отрезке, мы будем сводить этот запрос к двум суммам на префиксе: $\mathrm{sum}(l, r) = \mathrm{sum}(r) - \mathrm{sum}(l - 1)$. Оба этих запроса будем считать по формуле $\mathrm{sum}(k) = t_k + \mathrm{sum}(F(k) - 1)$.

Когда мы изменяем $i$-ю ячейку исходного массива, мы обновляем все $t_j$, в которых учтена эта ячейка.

$F$ можно выбрать так, чтобы и <<спусков>> при подсчёте суммы, и интересных нам $t_i$, при обновлении будет $O(\log n)$. Мы будем использовать формулу $F(x) = x - (x\:\&-x) + 1$. Позже мы приведём обоснование, почему эта формула действительно удовлетворяет нашим требованиям.

\subsubsection{Реализация}

Т.\,к. $F(0) = 1 > 0$, то $[F(0); 0]$ не является корректным отрезком. Поэтому нам будет удобнее хранить массив в $1$-индексации и не использовать $t_0$.

\begin{minted}[linenos, mathescape]{cpp}
// Возвращает сумму на префиксе
int summ(int r)
{
    int ans = 0;
    for (; r > 0; r -= r & -r)
        ans += t[r];
    return ans;
}

int summ(int l, int r)
{
    return summ(r) - summ(l - 1);
}

// Обновляет нужные $t$
void add(int j, int x)
{
    for (; j <= n; j += j & -j)
        t[j] += x;
}
\end{minted}

\subsubsection{Обоснование}

\begin{lemma}
    $x\:\&-x$ возвращает последний единичный бит в двоичной записи числа $x$.
\end{lemma}

\begin{proof}
    При применении $\&$, в префиксе до младшего единичного бита все биты $x$ и $-x$ будут противоположными, младший единичный бит остаётся единичным, а на суффиксе всё как было нулями, так и осталось.
\end{proof}

\begin{corollary}
    Запрос на сумму будет работать за логарифм, а точнее за количество единичных битов в записи $r$.
\end{corollary}

\begin{corollary}
    Запрос обновления тоже работает за $O(\log n)$: каждую итерацию количество нулей на конце $j$ увеличивается хотя бы на $1$.
\end{corollary}

\subsubsection{Многомерный случай}

Нужно добавить всего одну такую же строчку в \texttt{summ}, \texttt{add}, а также при подсчёте суммы на прямоугольнике вместо двух запросов к префиксным суммам использовать четыре.

\begin{minted}[linenos, mathescape]{cpp}
int sum(int r1, int r2)
{
    int ans = 0;
    for (int i = r1; i > 0; i -= i & -i)
        for (int j = r2; j > 0; j -= j & -j)
            ans += t[i][j];
    return ans;
}
\end{minted}

В $k$-мерном случае, по формуле включений-исключений, для запроса суммы нужно $2^k$ запросов суммы на префиксах.

\subsection{Разреженная таблица}

\begin{definition}
    \textit{Разреженная таблица} --- это следующий двумерный массив размера $\log_2n \times n$: $t_{k, i} = \min\{a_i, a_{i + 1}, \ldots, a_{i + 2^k + 1}\}$.
\end{definition}

То есть, мы считаем минимумы на каждом отрезке длины $2^k$. Такой массив можно посчитать за его размер, итерируясь либо по $i$, либо по $k$:
\[
    t_{k, i} = \min\{t_{k - 1, i}, t_{k - 1, i + 2^{k - 1}}\}.
\]

Имея такой массив, мы можем для любого отрезка быстро посчитать минимум на нём. Заметим, что у любого отрезка имеется два отрезка длины степени двойки, которые пересекаются и, главное, покрывают его и только его целиком. Значит, мы можем просто взять минимум из значений, которые соответствуют этим отрезкам.

Последняя делать: для того, чтобы константа на запрос стала настоящей, нужно научиться считать сам логарифм за константу. Для этого можно воспользоваться функцией \texttt{\_\_lg}.

\begin{minted}[linenos, mathescape]{cpp}
vector<int> a, mn;

int rmq(int l, int r) // полуинтервал $[l; r)$
{
    int t = __lg(r - l);
    return min(mn[t][l], mn[t][r - (1 << t)]);
}

// В содержательной части в main

memcpy(mn[0], a, sizeof a);

for (int l = 0; l < logn - 1; ++l)
    for (int i = 0; i + (1 << l) <= n; ++i)
        mn[l + 1][i] = min(mn[l][i], mn[l][i + (1 << l)]);
\end{minted}

Эту структуру тоже можно обобщить на б\'{о}льшие размерности. Пусть мы хотим посчитать RMQ на подквадратах. Тогда вместо массива $t_{k, i}$ у нас будет массив $t_{k, i, j}$, в котором вместо минимума на отрезках будет храниться минимум на квадратах тех же степеней двоек. Получение минимума на произвольном квадрате тогда уже распадётся на четыре минимума на квадратах длины $2^k$.

В общем же случае от нас просят минимум на прямоугольника $d$-мерного массива. Тогда делаем предпосчёт, аналогичный предыдущему случаю, только теперь тут будет $O(n\log^dn)$ памяти и времени на предпосчёт --- нужно хранить минимумы на всех параллелепипедах со сторонами, равными степеням двойки.

