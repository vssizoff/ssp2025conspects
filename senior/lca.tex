\section{Наименьший общий предок}

\subsection{Свойства DFS}

Посчитаем для каждой вершины времена входа и выхода при обходе в глубину:

\begin{minted}[linenos, mathescape]{cpp}
vector<vector<int>> adj;
vector<int> tin, tout;
int t = 0

void dfs(int u)
{
    tin[v] = t++;
    for (int v : adj[u])
        dfs(v);
    tout[u] = t; // можно и здесь увеличивать счётчик
}
\end{minted}

\begin{theorem}
    \begin{enumerate}[nolistsep]
        \item Вершина $u$ является предком $v$ $\Longleftrightarrow$ $\mathrm{tin}_v \in [\mathrm{tin}_u; \mathrm{tout}_u)$;
        \item Два полуинтервала --- $[\mathrm{tin}_v; \mathrm{tout}_v)$ и $[\mathrm{tin}_u; \mathrm{tout}_u)$ либо не пересекаются, либо один вложен в другой;
        \item В массиве $\mathrm{tin}$ есть все числа из $[0; n)$, причём у каждой вершины свой номер;
        \item Размер поддерева вершины $v$ (включая саму $v$) равен $\mathrm{tout}_v - \mathrm{tin}_v$;
        % \item Если ввести нумерацию вершин, соответствующую $\mathrm{tin}$-ам, то индексы любого поддерева всегда будут каким-то промежутком в этой нумерации.
    \end{enumerate}
\end{theorem}

\subsection{Основная задача и наивное решение}

\begin{problem}
    Дано корневое дерево. Требуется отвечать на запросы нахождения наименьшего общего предка вершин $u_i$ и $v_i$, т.\,е. вершины $w$, которая лежит на пути корня до $u_i$, на пути от корня до $v_i$, и при этом самую глубокую (нижнюю) из всех таких.
\end{problem}

За $O(n)$ наименьшего общего предка можно искать так:

\begin{minted}[linenos, mathescape]{cpp}
// Проверить, является ли $u$ предком $v$
bool a(int u, int v)
{
    return tin[u] <= tin[v] && tin[v] < tout[u];
}

int lca(int u, int v)
{
    while (!a(u, v))
        u = p[u];
    return u;
}
\end{minted}

\subsection{Двоичные подъёмы}

Предпосчитаем для каждой вершины её $2^i$-их предков и сохраним их в двумерном массиве $\mathrm{up}$ размера $n \times \lceil\log_2 n\rceil$: в $\mathrm{up}_{v, d}$ будет храниться предок вершины $v$ на расстоянии $2^d$, а если его не существует, то корень.

Такой предпосчёт можно выполнить за $O(n\log n)$, используя тот факт, что предок на расстоянии $2^{d + 1}$ --- это предок на расстоянии $2^d$ предка на расстоянии $2^d$.

\begin{minted}[linenos, mathescape]{cpp}
vector<vector<int>> up;
// В переменной logn будем хранить $\lceil\log_2n\rceil$

void dfs(int u)
{
    for (int l = 1; l < logn; ++l)
        up[u][l] = up[up[u][l - 1]][l - 1];
    tin[u] = t++;
    for (int v : adj[u])
    {
        if (v != up[u][0])
        {
            up[v][0] = u;
            dfs(v);
        }
    }
    tout[u] = t;
}
\end{minted}

Пусть теперь поступил запрос нахождения наименьшего общего предка пары вершин $(u, v)$:

\begin{enumerate}[nolistsep]
    \item Проверим, не является ли одна вершина предком другой --- в таком случае она и является результатом;
    \item Иначе, пользуясь массивом $\mathrm{up}$, будем подниматься по предкам одной из них, пока не найдём самую высокую вершину, которая ещё не является предком другой. Следующая за ней будет искомым наименьшим общим предком.
\end{enumerate}

Подробнее про второй пункт. Присвоим $i = \lceil\log_2n\rceil$ и будем уменьшать эту переменую на единицу, пока $\mathrm{up}_{v, i}$ не перестанет быть предком $u$. Когда это произойдёт, подвинем указатель на $2^i$-го предка $v$ и продолжим дальше.

\begin{minted}[linenos, mathescape]{cpp}
int lca(int v, int u)
{
    if (a(v, u)) return v;
    if (a(u, v)) return u;
    for (int l = logn - 1; l >= 0; --l)
        if (!a(up[v][l], u))
            v = up[v][l];
    return up[v][0];
}
\end{minted}

Указатель $\mathrm{up}_{v, i}$ изначально является корнем дерева, а затем будет каждую итерацию спускаться на $2^i$. Когда он станет потомком искомого общего предка, нам достаточно подняться всего лишь один раз, потому что два раза прыгнуть на расстояние $2^i$ --- это то же самое, что один раз прыгнуть на $2^{i + 1}$, а мы могли это сделать на предыдущем шаге.

Предпосчёт занимает $O(n\log n)$, потому что таков размер массива $\mathrm{up}$, и каждый его элемент вычисляется за константу. Ответ на произвольный запрос будет работать за $O(\log n)$, потому что фактически мы делаем один бинарный поиск.

