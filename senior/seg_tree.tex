\section{Дерево отрезков}

Пусть дан массив $\{a_0, \ldots, a_{n - 1}\}$ и функция $f$, т.\,ч. 
\[
    f\big(f([a_i\ldots a_j]), f([a_{j + 1}\ldots a_k])\big) = f([a_i\ldots a_k])
\]
для любых $i$, $j$, $k$, т.\,ч. $0 \leqslant i \leqslant j < k < n$.

\noindent
Мы научимся делать следующее:

\begin{enumerate}[nolistsep]
    \item Для любых $l$ и $r$ ($0 \leqslant l \leqslant r < n$) возвращать значение $f([a_l\ldots a_r])$ за $O(\log n)$;
    \item Для любых $i$ ($0 \leqslant i < n$) и $x$ заменять значение элемента $a_i$ на $x$ за~$O(\log n)$;
    \item Для любых $l$, $r$ ($0 \leqslant l \leqslant r < n$) и $x$ заменять значение каждого элемента на отрезке $[a_l\ldots a_r]$ на $x$ за $O(\log n)$. (Обобщение п.\,2)
\end{enumerate}

\begin{example}
    В качестве $f$ можно брать, например, сумму, $\max$ или $\min$.
\end{example}

\subsection{Основная идея}

Для этого мы рассмотрим структуру данных, называемую \textit{деревом отрезков}. Она представляет собой бинарное дерево, в котором в листьях хранятся элементы массива, а в каждой из остальных вершин --- результат вычисления функции $f$ от её сыновей.

Для вычисления функции на отрезке $[a_l\ldots a_r]$ мы будем спускаться по дереву и рассматривать три случая:

\begin{enumerate}[nolistsep]
    \item Отрезок, значение функции $f$ на котором хранится в текущей вершине, не пересекается с $[a_l\ldots a_r]$. Тогда возвращаем нейтральный элемент (такой элемент $e$, что $f(x, e) = f(e, x) = x$ для любого $x$).
    \item Отрезок, значение функции $f$ на котором хранится в текущей вершине, содержится (в нестрогом смысле) в $[a_l\ldots a_r]$. Тогда возвращаем значение в вершине.
    \item Отрезок, значение функции $f$ на котором хранится в текущей вершине, пересекается с $[a_l\ldots a_r]$. Тогда опускаемся на один уровень ниже в её сыновей.
\end{enumerate}

\begin{example}
    Нейтральным элементом для суммы является $0$, для максимума $-\infty$.
\end{example}

\begin{theorem}
    Высота дерева отрезков равна $\lceil\log_2n\rceil$.
\end{theorem}

\begin{proof}
    На последнем уровне в дереве должно находиться (не~более) $n$ вершин, вершин на $i$-ом слое (кроме, возможно, последнего) ровно $2^i$ (начиная с нуля). Наименьшее $i$, при котором $2^i \geqslant n$, равно $\lceil\log_2n\rceil$.
\end{proof}

\begin{corollary}
    Дерево отрезков хранит не более $4n$ вершин.
\end{corollary}

\begin{proof}
    Первый уровень содержит одну вершину (корень), второй --- две, третий --- четыре и так до $n$. Суммируя, получаем $1 + 2 \hm + \ldots + 2^{\lceil\log_2n\rceil} = 2^{\lceil\log_2n\rceil + 1} < 4n$.
\end{proof}

\begin{corollary}
    Время одной операции в дереве отрезков $O(\log n)$.
\end{corollary}

\begin{proof}
    Мы посещаем не более двух вершин на каждом слое, отсюда число операций составляет не более $2\lceil\log_2n\rceil$.
\end{proof}

Приступим к описанию реализации. Хранить дерево будем как массив, элементы которого отвечают за результат для текущей вершины в дереве. Из вершины с индексом $v$ в данном массиве виден левый сын по индексу $2v$, а правый --- по индексу $2v + 1$. Есть ещё некоторые приёмы, которые существенно упрощают написание:

\begin{enumerate}[nolistsep]
    \item Определиться заранее с нейтральным элементом;
    \item Написать один раз функцию \texttt{combine}, которая комбинирует результаты левого и правого сыновей;
    \item В качестве границ брать полуинтервалы вида $[l; r)$, а не отрезки.
\end{enumerate}

Обозначения: $v$ --- некоторая вершина дерева отрезков, которая хранит результат вычисления функции $f$ на полуинтервале $[t_l; t_r)$. Она является листом тогда и только тогда, когда $t_l + 1 = t_r$. Запросы будут подаваться на полуинтервалах $[q_l; q_r)$. Тогда отрезок, за который отвечает левый сын вершины $v$, есть $\left[t_l; \frac{t_l + t_r}{2}\right)$, а правый --- $\left[\frac{t_l + t_r}{2}; t_r\right)$.

\subsection{Построение}

\begin{minted}[linenos, mathescape]{cpp}
void build(int v, int tl, int tr)
{
    // Если $v$ - лист, положить в него элемент массива
    if (tl + 1 == tr)
        t[v] = a[tl];
    // Иначе положить в вершину комбинацию значений её сыновей
    else
    {
        int tm = (tl + tr) / 2;
        build(2 * v, tl, tm);
        build(2 * v + 1, tm, tr);
        t[v] = combine(t[2 * v], t[2 * v + 1]);
    }
}
\end{minted}

\subsection{Модификация}

Когда изменяется элемент массива, нужно изменить соответствующие вершины в дереве: нужно обновить лист, а также пересчитать значения, которые зависели от этого элемента. Такие вершины лежат по одной на~каждом уровне от корня до изменяемого листа. Значит, их количество не~более~$\log_2n$.

Находясь в вершине, нам надо спуститься в того сына, который отвечает за отрезок, в котором произойдёт изменение.

\begin{minted}[linenos, mathescape]{cpp}
void upd(int v, int tl, int tr, int pos, int val)
{
    if (tl + 1 == tr)
    {
        t[v] = val;
        return;
    }

    int tm = (tl + tr) / 2;
    if (pos < tm)
        upd(2 * v, tl, tm, pos, val);
    else
        upd(2 * v + 1, tm, tr, pos, val);
    t[v] = combine(t[2 * v], t[2 * v + 1]);
}
\end{minted}

\subsection{Получение результата}

\begin{minted}[linenos, mathescape]{cpp}
int get(int v, int tl, int tr, int ql, int qr)
{
    if (qr <= tl || tr <= ql)
        return NEUTRAL; // $[t_l; t_q]$ не пересекается с $[q_l; q_r]$
    if (ql <= tl && tr <= qr)
        return t[v]; // $[t_l; t_q]$ содержится в $[q_l; q_r]$

    // Иначе комбинируем результат сыновей
    int tm = (tl + tr) / 2;
    return combine(get(2 * v, tl, tm, ql, qr), \
                   get(2 * v + 1, tm, tr, ql, qr));
}
\end{minted}

\subsection{Массовые операции}

Теперь пусть запрос модификации представляет собой прибавление ко всем числам на некотором подотрезке $[a_l\ldots a_r]$ некоторого числа $x$, а запрос чтения --- считывание некоторого числа $a_i$.

Чтобы обрабатывать запрос прибавления эффективно, будем хранить в каждой вершине дерева отрезков, сколько нужно прибавить к каждому числу этого отрезка. Тем самым мы сможем обрабатывать запрос прибавления на любом подотрезке эффективно за $O(\log n)$ вместо того, чтобы на каждом запросе менять все $O(n)$ значений.

Чтобы обработать запрос чтения значения $a_i$, достаточно спуститься по дереву, просуммировав все встреченные по пути значения, записанные в вершинах дерева. Сложность этого решения составляет $O(\log n)$ из-за~высоты дерева.

\begin{minted}[linenos, mathescape]{cpp}
void upd(int v, int tl, int tr, int ql, int qr, int x)
{
    if (ql >= qr)
        return;
    if (ql == tl && qr == tr)
        t[v] += x;
    else
    {
        int tm = (tl + tr) / 2;
        upd(2 * v, tl, tm, ql, min(qr, tm), x);
        upd(2 * v + 1, tm, tr, max(ql, tm), qr, x);
    }
}

int get(int v, int tl, int tr, int pos)
{
    if (tl + 1 == tr)
        return t[v];
    int tm = (tl + tr) / 2;
    if (pos < tm)
        return t[v] + get(2 * v, tl, tm, pos);
    else
        return t[v] + get(2 * v + 1, tm, tr, pos);
}
\end{minted}

Попробуем обобщить эту идею для произвольной операции и посмотрим, в какие ограничения мы упираемся. Пусть $\otimes$ --- некоторая операция. Рассмотрим, что будет происходить со значением $a_i$ при запросах $x$ и $y$, которые его изменяли.

Спускаясь по дереву от корня до листа, мы пересчитываем значение не в том порядке, как мы их должны применить, следуя запросам, так что $(a_i \otimes x) \otimes y = a_i \otimes (x \otimes y)$, т.\,е. операция $\otimes$ должна быть ассоциативна.

Также значение $a_i$ не должно зависеть от порядка запросов над ним, так что $a_i \otimes x \otimes y = a_i \otimes y \otimes x$ --- это коммутативность.

\subsection{Некоммутативные операции и присвоение на отрезке}

Научимся работать с некоммутативными операциями на примере присвоения, ведь его можно рассматривать как операцию $x \odot y \vcentcolon = y$.

\begin{remark}
    Заметим, что присвоение является ассоциативной операцией: $(x \odot y) \odot z = z$, $x \odot (y \odot z) = x \odot z = z$.
\end{remark}

Рассмотрим задачу, в которой запрос чтения --- получение значения массива $a_i$, а модификации есть присвоение всем элементам некоторого отрезка $[a_l\ldots a_r]$ некоторого значения $p$. При этом будем говорить, что мы красим отрезок $[a_l\ldots a_r]$ в цвет $p$.

Чтобы делать модификацию на целом отрезке, разобьём его на набор подотрезков, каждый из которых покрывается какой-то вершиной \mbox{дерева}. Разбиение мы делаем спуском, как и до этого. Мы будем \mbox{красить} не \mbox{каждый} элемент массива на интересующем нас отрезке, а только \mbox{вершины} полученного разбиения. То же самое мы делали, когда решали задачу о~прибавлении на отрезке.

Итак, после выполнения запроса модификации дерево отрезков становится, вообще говоря, неактуальным --- в нём остались недовыполненными некоторые модификации.

Теперь предположим, что после покраски отрезка $[a_l\ldots a_r]$ в какой-то цвет нам пришёл запрос модификации какого-то его подотрезка $[a_{l^\prime}\ldots a_{r^\prime}]$ в другой цвет. Мы хотим покрасить вершины \mbox{разбиения} \mbox{этого} подотрезка (которые являются, возможно, непрямыми, потомками \mbox{ранее} покрашенных вершин). Проблема в том, что до покраски этих вершин мы должны разобраться с изначальными вершинами разбиения, при этом утратится информация о покраске для вершин из нашего отрезка, не~входящих в $[a_{l^\prime}\ldots a_{r^\prime}]$.

Выход в том, чтобы произвести \textit{проталкивание} информации из корня, т.\,е. если корень поддерева был покрашен в какой-либо цвет, то покрасить в этот цвет его правого и левого сына, а из корня эту отметку убрать. После этого мы можем красить сыновей корня, не теряя никакой важной информации.

Асимптотика такого решения есть $O(\log n)$, что доказывается аналогично следствию 2.

Для реализации нам нужно написать дополнительную функцию, которая будет производить проталкивание информации из вершины в её сыновей, и вызывать эту функцию в самом начале обработки запросов (но не из листьев).

% TODO: ПЕРЕДЕЛАТЬ

\begin{minted}[linenos, mathescape]{cpp}
void push(int v)
{
    if (t[v] >= 0)
    {
        t[2 * v] = t[2 * v + 1] = t[v];
        t[v] = -1; // обозначение отсутствия изменения
    }
}

void upd(int v, int tl, int tr, int ql, int qr, int p)
{
    if (ql >= qr)
        return;
    if (ql == tl && qr == tr)
        t[v] = p;
    else
    {
        push(v);
        int tm = (tl + tr) / 2;
        upd(2 * v, tl, tm, ql, min(qr, tm), p);
        upd(2 * v + 1, tm, tr, max(ql, tm), qr, p);
    }
}

int get(int v, int tl, int tr, int pos)
{
    if (tl + 1 == tr)
        return t[v];
    push(v);
    int tm = (tl + tr) / 2;
    if (pos < tm)
        return get(2 * v, tl, tm, pos);
    else
        return get(2 * v + 1, tm, tr, pos);
}
\end{minted}

\begin{remark}
    Функцию \texttt{get} можно было реализовывать и по-другому: не делать в ней запаздывающих обновлений, а сразу возвращать ответ, как только мы попадаем в вершину дерева, целиком покрашенную в тот или иной цвет.
\end{remark}
