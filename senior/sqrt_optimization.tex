\section{Корневые оптимизации}

Иногда в задаче возникают ситуации, когда мы умеем решать её, когда для какой-то величины выполнено свойство, что она всегда либо меньше, либо больше, чем $\sqrt{n}$. Данный подход и называется корневой оптимизацией.

Примерами применения данной идеи могут служить: алгоритм проверки числа на простоту за $O(\sqrt{n})$ или факт, что если сумма неотрицательных чисел равна $n$, то различных среди них не более $\sqrt{n}$. Также можно вспомнить идею, что если $a \cdot b \leqslant n$, то одно из чисел $a$ или $b$ должно не превышать $\sqrt{n}$.

\subsection{Корневая декомпозиция на массиве}

\begin{problem}
    Дан массив $\{a_0, a_1, \ldots, a_n\}$. Нужно обрабатывать на нём два типа запросов:
    \begin{enumerate}[nolistsep]
        \item Найти сумму на отрезке $[a_l\ldots a_r]$;
        \item Увеличить значение $i$-го элемента на $x$.
    \end{enumerate}
\end{problem}

Разобьём массив на блоки размера $s = \lceil\sqrt{n}\rceil$ и в каждом блоке $i$ предпосчитаем сумму $b_i$ элементов в нём. Массив разбивается на блоки примерно так:
\[
    \underbrace{a_0, a_1, \ldots, a_{s - 1}}_{b_0},\ \underbrace{a_s, a_{s + 1}, \ldots, a_{2 \cdot s - 1}}_{b_1},\ \ldots,\ \underbrace{a_{(s - 1) \cdot s}, a_{(s - 1) \cdot s + 1}, \ldots, a_{n - 1}}_{b_{s - 1}}.
\]

Последний блок может содержать меньше, чем $s$ элеметов (если $n$ не является полным квадратом), --- это не существенно. Итак, на каждом блоке $i$ мы знаем сумма на нём
\[
    b_i = \ds\sum_{j = s \cdot i}^{\min\{n - 1, (i + 1) \cdot s - 1\}}a_i.
\]

Этот предпосчёт занял у нас $O(n)$ времени. Теперь чтобы посчитать сумму на отрезке $[a_l\ldots a_r]$, нужно посчитать за $O(\sqrt{n})$ суммы на перфиксе и суффиксе до ближайшего блока, а потом прибавить сумму чисел в нём.

\begin{minted}[linenos, mathescape]{cpp}
int n, m; // $n$ - длина массива, $m$ - число запросов
cin >> n >> m;
vector<int> a(n);
for (int i = 0; i < n; ++i)
    cin >> a[i];

// Предпосчёт
int s = (int)sqrt((ld)n) + 1;
vector<int> b(s, 0);
for (int i = 0; i < n; ++i)
    b[i / s] += a[i];

while (m--)
{
    int l, r;
    cin >> l >> r;
    int summ = 0;
    int i = l;
    while (i <= r)
    {
        if (!(i % s) && i + s - 1 <= r)
        {
            summ += b[i / s];
            i += s;
        }
        else
        {
            summ += a[i];
            ++i;
        }
    }
}
\end{minted}

В блоках корневой декомпозиции можно хранить не только значения функций для подотрезка, а ещё и его отсортированную версию. Это бывает полезно при ответе на запросы вида <<сколько элементов, меньших~$x$, на отрезке>> и используется в техниках \texttt{split-rebuild} и \texttt{split-merge}.

\subsection{Split-rebuild}

\begin{problem}
    Пусть дан массив $\{a_0, a_1, \ldots, a_{n - 1}\}$. К нему поступает $M$ запросов, каждый одного из трёх видов:

    \begin{enumerate}[nolistsep]
        \item Вставить элемент $x$ на позицию $i$ (т.\,е. слева от него должно оказаться $i$ элементов);
        \item Удалить элемент с позиции $i$;
        \item Найти минимум на полуинтервале $[l; r)$.
    \end{enumerate}
\end{problem}

\subsubsection{Вставка}

При вставке будем явно вставлять элемент в нужный блок. Если вставка происходит на границе блоков, то договоримся вставлять элемент в единственный существующий блок, если вставка происводится в самый конец или самое начало. Иначе вставляем в блок, найденный функцией \texttt{find\_pos} (возвращает нужный блок и позицию в нём). Можно сделать иначе при вставке на концах --- вставлять в новый блок, создавая его. Этот случай будет лучше работать, если у нас происходит много вставок подряд, а предыдущий --- когда надо больше отвечать за запросы. Можно также принимать решение о вставке тем или иным способом случайно.

\begin{minted}[linenos, mathescape]{cpp}
void insert_to_block(int pos, int elem)
{
    if (b.empty())
    {
        b.resize(1);
        b[0].push_back(elem);
        return;
    }
    pair<int, int> block_pos = find_pos(pos);
    if (block_pos.first == b.size())
    {
        b.back().push_back(elem);
        return;
    }
    insert(b[block_pos.first].begin() + block_pos.second, elem);
}
\end{minted}

\subsubsection{Удаление}

При удалении будем явно удалять элемент из блока за размер блока. Если блок оказался пустым, то ничего с ним не будем делать пока что.

\subsubsection{Функция на подотрезке}

Запрос о вычислении функции обрабатываем, как в обычной корневой декомпозиции.

\subsubsection{Перестраивание}

Чтобы не допускать создания слишком большого числа маленьких блоков или разрастания отдельных блоков, раз в $\sqrt{n}$ операций будем заново полностью перестраивать структуру. Размер блока при этом тоже будет меняться. Также будем всегда поддерживать размер всей \mbox{структуры}.

\begin{minted}[linenos, mathescape]{cpp}
void rebuild()
{
    int new_block_size = sqrt(b.size()) + 1;
    vector<int> all;
    for (vector<int> block : b)
        for (int elem : block)
            all.push_back(elem);

    b.clear();
    int new_blocks_cnt = (all.size() + new_block_size - 1) /
                         new_block_size;
    b.resize(new_blocks_cnt);
    for (int i = 0; i < all.size(); ++i)
    {
        b[i / new_block_size].push_back(all[i]);
        update(i); // обновить значение блока
        // в соответствие с задачей
    }
}
\end{minted}

\subsubsection{Как искать нужный блок}

Т.\,к. теперь мы не можем гарантировать, что блок имеет фиксированный размер в каждый момент времени, то находить нужное место будем просто проходом по массиву блоков.

\begin{minted}[linenos, mathescape]{cpp}
pair<int, int> find_pos(int pos)
{
    if (b.empty() || !pos)
        return {0, 0};
    int by_left = 0;
    int i = 0;
    while (i < b.size() && by_left < pos)
    {
        by_left += b[i].size();
        ++i;
    }
    by_left -= b[i].size();
    --i;
    return {i, pos - by_left};
}
\end{minted}

\subsection{Split-merge}

\subsubsection{Основная идея}

В рамках техники \texttt{split-rebuild} мы регулярно перестраивали структуру данных. Оказывается, бывают ситуации, когда перестраивать структуру данных не так выгодно, как поддерживать её в сбалансированном состоянии.

\begin{problem}
    Пусть дан массив $\{a_0, a_1, \ldots, a_{n - 1}\}$ . К нему поступает $m$ запросов, каждый одного из четырёх видов:

    \begin{enumerate}[nolistsep]
        \item Вставить элемент $x$ на позицию $i$ (т.\,е. слева от него должно оказаться $i$ элементов);
        \item Удалить элемент с позиции $i$;
        \item Ответ на запрос на количество элементов, не меньших $a$ на полуинтервале $[l; r)$; (\texttt{lower\_bound})
        \item Массовые операции (например, переворот отрезка).
    \end{enumerate}
\end{problem}

Заметим, что эту задачу мы уже могли решить с помощью \texttt{split-rebuild}. Для этого нам нужно было бы хранить для каждого блока его отсортированную версию. Если для каждого отсортированного элемента хранить его исходный индекс, то можно будет делать \texttt{split} за линейное время. Таким образом, у нас будет асимптотика $O(q\sqrt{n}\log n)$, ведь теперь для \texttt{rebuild} и \texttt{lower\_bound} нам понадобится сортировка.

\subsubsection{Склеиваем блоки}

Теперь заметим, что мы можем склеить два соседних маленьких блока за $O(k)$, где $k$ --- размер блока, с помощью стандартного слияния. Тогда будем склеивать блоки, если существует пара соседних блоков, каждый из которых меньше, чем $\frac{k}{2}$. А резать блок будем, если его размер больше $2k$. Тогда блоков всегда будет $O\br{\frac{n}{k}}$, а размер блоков будет $O(k)$.

\subsection{Корневая декомпозиция в задачах на графы}

\begin{definition}
    Назовём вершину \textit{тяжёлой}, если она имеет более $\sqrt{\abs{E}}$ соседей. Иначе, назовём вершину \textit{тяжёлой}.
\end{definition}

\begin{lemma}
    В графе не более $2 \cdot \sqrt{\abs{E}}$ тяжёлых вершин.
\end{lemma}

\begin{proof}
    Пусть в графе более $2 \cdot \sqrt{\abs{E}}$ тяжёлых вершин. Тогда числ о рёбер в графе больше, чем $\frac{2 \cdot \sqrt{\abs{E}} \cdot \sqrt{\abs{E}}}{2} = \abs{E}$, противоречие.
\end{proof}

\begin{problem}
    Найти количество треугольников в графе за $O(\abs{E}\sqrt{\abs{E}})$.
\end{problem}

Разобьём все вершины графа на лёгкие и тяжёлые. Заметим, что треугольников, образованных только тяжёлыми вершинами, всего $C_{\sqrt{E}}^3 \hm = O(\abs{E}\sqrt{\abs{E}})$. Теперь рассмотрим треугольники, которые содержат в себе лёгкие вершины. В таком треугольнике точно будут два ребра, инцидентных лёгкой вершине. Сколько таких пар может быть? Всего таких рёбер $O(\abs{E})$, при этом для каждого ребра парными могут быть только $O(\sqrt{\abs{E}})$ рёбер, в силу степени лёгкой вершины. Таким образом, число треугольников в графе равно $O(\abs{E}\sqrt{\abs{E}})$. Каким алгоритмом их искать? Можно явно провести процесс, описанный выше, но это не самое приятное в реализации решение этой задачи.

Можно переориентировать рёбра от вершин с меньшей степенью к вершинам с большей. Теперь верно следующее.

\begin{lemma}
    Из каждой вершины выходит не более $O(\sqrt{\abs{E}})$ рёбер.
\end{lemma}

\begin{proof}
    Степень лёгких вершин $O(\sqrt{\abs{E}})$, а из тяжёлых вершин рёбра идут только в тяжёлые, которых всего $O(\sqrt{\abs{E}})$.
\end{proof}

Теперь для каждой вершины пометим её соседей, после чего запустим поиск путей длины $2$ и будем фиксировать треугольник при нахождении пометки. Для каждого первого ребра пути мы посмотрим на $O(\sqrt{\abs{E}})$ рёбер, поэтому итоговая сложность алгоритма $O(\abs{E}\sqrt{\abs{E}})$.

\subsection{Корневая декомпозиция на строках}

Данные идеи очень полезны в задачах, где есть ограничение на суммарный размер строк. Обозначим это ограничение за $\sum\limits\abs{s}$.

\begin{definition}
    Назовём строку $s$ \textit{длинной}, если $\abs{s} \geqslant \sqrt{\sum\abs{s}}$. Иначе будем называть строку $s$ \textit{короткой}.
\end{definition}

\begin{lemma}
    Существует не более $\sqrt{\sum\abs{s}}$ длинных строк.
\end{lemma}

\begin{proof}
    Пусть существует более $\sqrt{\sum\abs{s}}$ длинных строк. Тогда их суммарная длина больше $\sqrt{\sum\abs{s}} \cdot \sqrt{\sum\abs{s}} = \sum\abs{s}$, противоречие.
\end{proof}

\begin{lemma}
    Количество различных длин строк не более, чем $O(\sqrt{\sum\abs{s}})$.
\end{lemma}

\begin{proof}
    Пусть количество различных длин равно $x$. Тогда минимальная возможная сумма длин --- это сумма чисел от $1$ до $x$, равная $\frac{x(x + 1)}{2} < \sum\abs{s}$, отсюда $x = O(\sqrt{\sum\abs{s}})$.
\end{proof}

