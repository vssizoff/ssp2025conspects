\section{Линейные алгоритмы}

\subsection{Префиксные суммы}

\begin{problem}
    Дан массив $\{a_0, a_1, \ldots, a_{n - 1}\}$. На $k$-ом из $m$ запросов даётся пара чисел $(l_k, r_k)$, т.\,ч. $0 \leqslant l_k \leqslant r_k < n$; нужно найти сумму $a_{l_k} + a_{l_k + 1} \hm + \ldots + a_{r_k}$.
\end{problem}

\begin{definition}
    \textit{Массивом префиксных сумм} массива $\{a_0, a_1, \ldots, a_{n - 1}\}$ называется массив (длины $n + 1$) $\{p_0, p_1, \ldots, p_n\}$, для которого $p_i \vcentcolon = \sum\limits_{j < i}a_j$. Иными словами, $p_0 = 0$, $p_1 = a_0$, $p_2 = a_0 + a_1$ и т.\,д.
\end{definition}

Нетрудно заметить, что $p_i = p_{i - 1} + a_{i - 1}$, поэтому массив префиксных сумм можно строить за линейное время. При этом, $\sum\limits_{i = l_k}^{r_k}a_i = p_{r_k + 1} - p_{l_k}$, т.\,е. ответ на каждый запрос даём за $O(1)$, поэтому итоговая сложность составляет $O(n + m)$.

\begin{minted}[linenos, mathescape]{cpp}
vector<int> p(n + 1); p[0] = 0;
for (int i = 1; i <= n; ++i)
    p[i] = p[i - 1] + a[i - 1]; // $p_0 = 0,\ p_i = a_0 + \ldots + a_{i - 1}$.
int m;
cin >> m;
while (m--)
{
    int l, r;
    cin >> l >> r;
    cout << p[r + 1] - p[l] << '\n';
}
\end{minted}

\subsection{Поиск оптимальной пары}

\begin{problem}
    В массиве $\{a_0, a_1, \ldots, a_{n - 1}\}$ найти пару $(i, j)$ такую, что $i < j$ и значение $a_j - a_i$ максимально возможное.
\end{problem}

\begin{wrapfigure}{r}{.35\textwidth}
    \begin{asy}
        defaultpen(fontsize(11pt));
        size(4cm);
        pair u = (1, -1), v = (3, 2), O = (0, 0);
        draw((O - 3 * u) -- (O) -- (O + v) -- (O + v + 2 * u));

        dot("$a_i$", O, 1.5 * dir(-60));
        dot("$a_j$", O + v, dir(45));
    \end{asy}
\end{wrapfigure}

Будем идти по массиву слева направо, \mbox{перебирая} правый элемент пары, а левый каждый раз выбирать наилучшим образом. Если правый элемент на данном шаге \mbox{имеет} индекс $j$, то наилучшим \mbox{левым} для него является $\min\{a_0, a_1, \ldots, a_{j - 1}\}$, ведь разность тем больше, чем меньше \mbox{вычитаемое}. При~этом, на~каждом новом шаге к рассмотрению добавляется ровно один элемент, поэтому для каждого правого элемента наилучший левый находим за~$O(1)$, поэтому всё решение работает за $O(n)$.

\begin{minted}[linenos, mathescape]{cpp}
int ibest = 0, jbest = 1;
int imin = 0;
for (int j = 2; j < n; ++j)
{
    if (a[j - 1] < a[imin]) imin = j - 1;
    if (a[j] - a[imin] > a[jbest] - a[ibest])
        ibest = imin, jbest = j;
}
cout << ibest << ' ' << jbest << '\n';
\end{minted}

\begin{problem}
    Даны массив $\{a_0, a_1, \ldots, a_{n - 1}\}$ и натуральное число $k$. Нужно найти пару $(i, j)$ такую, что $j - i \geqslant k$ и значение $a_i + a_j$ максимально возможное.
\end{problem}

Здесь применяем ту же идею, что и в задаче о поиске оптимальной \mbox{пары}, но с некоторыми модификациями. Во-первых, начинаем \mbox{перебирать} элемент $j$ не с начала, а с индекса $k$ (ведь до этого мы очевидно не~\mbox{найдём} подходящего индекса $i$). Во-вторых, лучшим элементом для $j$-го \mbox{теперь} является $\max\{a_0, a_1, \ldots, a_{j - k}\}$.

\subsection{Суммы на отрезках}

\begin{problem}
    В массиве $\{a_0, a_1, \ldots, a_{n - 1}\}$ нужно найти подотрезок $[a_l\ldots a_r]$, сумма на котором максимально возможная.
\end{problem}

Сразу отметим, что если данный массив состоит из неотрицательных чисел, то ответом всегда будет являться весь массив; сложности возникают, если разрешены отрицательные числа. Однако они разрешимы, \mbox{если} уметь решать первые две задачи в этой лекции. Для решения можно \mbox{предпосчитать} массив префиксных сумм данного массива, а затем для~него решить задачу о нахождении оптимальной пары.

Предположим теперь, что нам нужно найти лишь саму максимальную сумму, а не отрезок, на котором она достигается. У такой задачи есть очень изящное решение. Построим последовательность:
\[
    s_0 \vcentcolon = 0,\quad s_i \vcentcolon = \max\{s_{i - 1} + a_{i - 1}, 0\}\ (1 \leqslant i \leqslant n).
\]

Фактически, мы просто накапливаем префиксную сумму, но если она становится отрицательной, мы ставим её в $0$.

\begin{statement}
    Максимальная сумма на подотрезке данного массива равна $\max\{s_0, \ldots, s_n\}$.
\end{statement}

\begin{proof}
    Точки $i$, в которых $s_i = 0$, назовём \textit{критическими}. Заметим, что каждое $s_i$ равно сумме на подотрезке от ближайшей слева критической точки до $i$ (совпадение этих точек допускается в случае, если точка $i$ сама является критической). Отметим, что для каждого $i$ такая точка определена, т.\,к. $s_0 = 0$; обозначим её через $i^\ast$. Докажем, что максимальная сумма достигается на одном из таких отрезков. \mbox{Рассмотрим} произвольный отрезок $[a_l\ldots a_r]$. Сумма на отрезке $[a_{l^\ast}\ldots a_l]$ равна $s_l$ и, как следствие, неотрицательна. Поэтому сумма на отрезке $[a_{l^\ast}\ldots a_r]$ не~меньше, чем на $[a_l\ldots a_r]$, так что достаточно смотреть только на отрезки, начинающиеся в критических точках.
\end{proof}

На самом деле, к описанному алгоритму тоже можно <<прикрутить>> нахождение отрезка, на котором достигается максимум. Искомый отрезок есть $[a_{j^\ast}\ldots a_j]$, где $j$ --- индекс максимального члена последовательности $\{s_i\}$, а $j^\ast$ --- ближайшая к нему слева критическая точка.

\begin{problem}
    В массиве $\{a_0, a_1, \ldots, a_{n - 1}\}$ неотрицательных чисел найти подотрезок $[a_l\ldots a_r]$, сумма на котором равна заданному значению $k$.
\end{problem}

Будем искать отрезок следующим образом. Начнём с отрезка $[a_0]$, \mbox{состоящим} из одного элемента. На каждом шаге если сумма на \mbox{отрезке} меньше $k$, будем двигать правую границу отрезка на $1$ вправо (при этом сумма на отрезке не уменьшится), если меньше --- сдвинем левую \mbox{границу} на $1$ вправо (при этом сумма на отрезке не увеличится). Из \mbox{принципа} \mbox{дискретной} непрерывности, мы либо найдём искомый отрезок, либо правый конец отрезка начнёт указывать на индекс $n$.

\begin{minted}[linenos, mathescape]{cpp}
int i = 0, j, s = a[0];
for (j = 0; j < n; )
{
    if (s == k) break;
    if (s < k)
    {
        ++j;
        if (j < n) s += a[j];
    }
    else
    {
        s -= a[i];
        ++i;
    }
}

if (s == k)
    cout << i << ' ' << j << '\n';
else
    cout << "NO SOLUTION\n";
\end{minted}
