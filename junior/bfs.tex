\section{Введение в графы. Обход в ширину}

Будем рассматривать граф $G$ с множеством вершин $V \vcentcolon = \{0, 1, \ldots, n \hm - 1\}$ и множеством рёбер $E$. 

\subsection{Способы хранения графов}

Есть несколько способов хранения графов, каждый из которых удобен в разных ситуациях.

\begin{enumerate}
    \item \textbf{Список рёбер}. Название говорит само за себя: заводится массив, в котором хранятся рёбра в виде пар инцидентных вершин. Применяется, например, в алгоритме Краскала (см.\,лекцию по СНМ).
    \item \textbf{Матрица смежности}. Заведём двумерный массив $a$ размера $n \times n$, заполненный следующим образом:
    \[
    a_{ij} =
    \begin{cases}
        1,&\text{если $(i, j) \in E$},\\
        0,&\text{иначе}.
    \end{cases}
    \]
    Отметим, что для неориентированного графа матрица смежности является симметрической.
    \item \textbf{Список смежности}. Заведём двумерный массив $a$ размера $n$, в котором по индексу $i$ хранится массив вершин, инцидентных $i$. Этот способ обычно удобнее всего, т.\,к. 1) удобнее всего получать соседей для каждой вершины; 2) суммарный размер $O(m)$, а не $O(n^2)$, что полезно, когда $m \sim n$.
\end{enumerate}

\subsection{Идея поиска в ширину}

При обходе в ширину мы идём по вершинам в порядке, в котором они бы сгорали, если поджечь начальную (каждую секунду огонь распространяется на соседние вершины). Моделируем данный процесс, пока не сгорит весь граф. Важно помнить, что мы не поджигаем уже горящие вершины. Т.\,к. огонь распространяется равномерно по кратчайшим путям, секунда, на которой сгорела $i$-я вершина --- это расстояние до неё.

\subsection{Реализация}

\begin{minted}[linenos, mathescape]{cpp}
// Список смежности графа $G$ размера $n$
vector<vector<int>> adj;
// Векторы для хранения расстояний до каждой вершины
// и её предков
vector<int> dist, parent;

void bfs(int start)
{
    queue<int> q; // Очередь для хранения горящих вершин
    dist.assign(n, INF);
    parent.assign(n, -1);
    q.push(start);
    dist[start] = 0;
    while (!q.empty())
    {
        int v = q.front();
        q.pop();
        for (auto u : adj[v])
        {
            if (dist[u] == INF)
            {
                dist[u] = dist[v] + 1;
                parent[u] = v;
                q.push(u);
            }
        }
    }
}
\end{minted}

Множество пройденных ребёр $(v, p_v)$ образует дерево (\textit{дерево обхода}).

