\section{Бинарный и тернарный поиски}

\subsection{Основная идея}

Предположим, есть массив $\{a_0, a_1, \ldots, a_{n - 1}\}$ и некоторое монотонное свойство $P$ в том смысле, что найдётся такой $i_0 \in [0; n)$, что $P(a_i) = P(a_j)$ для любых $i, j < i_0$ и для любых $i, j \geqslant i_0$, но $P(a_i) \ne P(a_j)$ для любых $i, j$, т.\,ч. $i < i_0 \leqslant j$.

Наша задача --- найти этот индекс $i_0$. Мы будем делать это следующим образом. Зафиксируем начало и конец полуинтервала поиска: $l \vcentcolon = 0$, $r \vcentcolon = n$. Если $P\br{a_{\lfloor(l + r) / 2\rfloor}} = P(a_l)$, то индекс перехода $i_0$ находится где-то на второй половине полуинтервала; иначе --- на первой. Обновляем значения $l$ и $r$ в соответствии с новым интервалом поиска. Алгоритм продолжает работу до тех пор, пока $l < r + 1$ (т.\,е. множество $[l; r)$ непусто).

Каждый раз интервал поиска уменьшается в два раза, так что совершаем $O(\log n)$ действий, а точнее --- либо $\lceil\log_2n\rceil$, либо $\lfloor\log_2n\rfloor$. Наивное решение (пройти по всем элементам массива) имеет асимптотику $O(n)$.

\subsection{Реализация}

\begin{problem}
    Найти в отсортированном массиве $\{a_0, a_1, \ldots, a_{n - 1}\}$ элемент, равный $x$, или определить, что его там нет.
\end{problem}

Положим $
P(a_i) =
\begin{cases}
    1,&\text{если $a_i \geqslant x$},\\
    0,&\text{иначе}
\end{cases}
$. Находим граничный элемент следующим образом:

\begin{minted}[linenos, mathescape]{cpp}
int l = 0, r = n;
while (l < r + 1)
{
    int m = (l + r) / 2;
    if (a[m] > x)
        r = m;
    else
        l = m;
}
\end{minted}

\subsection{Вещественный бинарный поиск}

Пусть теперь нам дана некоторая функция $f: \R \to \R$. Известно, что она непрерывна на отрезке $[a; b]$ и $f(a) \cdot f(b) < 0$. Теорема из математического анализа говорит, что у этой функции есть корень на данном отрезке. Искать его можно так же бинарным поиском, только теперь будем выполняться, пока $r - l > \varepsilon$, где $\varepsilon$ выбирается исходя из необходимой в задаче погрешности.

\begin{minted}[linenos, mathescape]{cpp}
long double l = a, r = b;
long double eps = 1e-6; // ... например
while (r - l > eps)
{
    long double m = (l + r) / 2;
    if (f(m) >= 0)
        r = m;
    else
        l = m;
}
\end{minted}

А можно делать фиксированное количество итераций, при этом чтобы получить $k$ правильных цифр, необходимо выполнить не менее $k \cdot \log_210$ операций.

\subsection{Бинарный поиск по ответу}

\begin{problem}
    На прямой расположены $n$ стойл (даны их координаты на прямой), в которые необходимо расставить $k$ коров так, чтобы минимальное расстояние между коровами было как можно больше. Гарантируется, что $1 < k < n$.
\end{problem}

Если решать задачу в лоб, то вообще неясно, что делать. Вместо этого решим более простую задачу: предположим, что мы знаем это расстояние $x$, ближе которого коров ставить нельзя. Тогда сможем ли мы расставить всех коров в соответствие с условием? Заметим, что это свойство монотонно --- для каких-то маленьких $x$ коров точно можно расставить, а начиная с каких-то больших --- уже нельзя, поэтому эту границу можно искать бинарным поиском.

\begin{minted}[linenos, mathescape]{cpp}
bool check(int x)
{
    int cows = 1;
    int last_cow = a[0];
    for (int c : a)
    {
        if (c - last_cow >= x)
        {
            ++cows;
            last_cow = c;
        }
    }
    return (cows >= k);
}

int bin_search()
{
    // Предполагаем, что координаты
    // в массиве $a$ уже отсортированы
    int l = 0, r = a.back() - a[0] + 1;
    while (r - l > 1)
    {
        if (check(m))
            l = m;
        else
            r = m;
    }
    return l;
}
\end{minted}

\begin{problem}
    Есть два принтера. Один печатает лист раз в $x$ минут, другой --- раз в $y$ минут. За сколько минут они напечатают $n$ листов?
\end{problem}

Конечно, эту задачу можно решить формулой за $O(1)$. Однако если такую формулу придумать не получается, сведём задачу к обратной. Подумаем, как по числу минут $t$ понять, сколько листов напечатается за это время? Очень легко:
\[
    \lfloor\frac{t}{x}\rfloor + \lfloor\frac{t}{y}\rfloor.
\]

Ясно, что за $0$ минут $n$ листов наспечатать нельзя, а за $x \cdot n$ минут один только первый принтер успеет напечатать $n$ листов. Поэтому $0$ и $x \cdot n$ --- это подходящие начальные границы для бинарного поиска.

\subsection{Тернарный поиск}

Пусть дана функция $f(x)$ имеем ровно один \textit{экстремум} --- локальный максимум или локальный минимум на отрезке $[a; b]$. Требуется найти точку этого экстремума.

Возьмём любые две точки $m_1$ и $m_2$ на этом отрезке: $l < m_1 < m_2 < r$. Посчитаем значения функции $f(m_1)$ и $f(m_2)$. Дальше у нас получается три варианта:

\begin{enumerate}[nolistsep]
    \item Если окажется, что $f(m_1) < f(m_2)$, то искомый максимум может находиться только в правой части, т.\,е. на отрезке $[m_1; r]$;
    \item Если, наоборот, $f(m_1) > f(m_2)$, то искомый максимум может находиться только в левой части, т.\,е. на отрезке $[l; m_2]$;
    \item А если $f(m_1) = f(m_2)$, то максимум находится на отрезке $[m_1; m_2]$, однако этот случай в целях упрощения кода можно отнести к любому из двух предыдущих.
\end{enumerate}

Выполнение алгоритма завершается, когда отрезок поиска станет достаточно маленьким. Осталось заметить, что мы не накладывали никаких ограничений на выбор точек $m_1$ и $m_2$. От этого способа будет зависеть скорость сходимости (и возникающая погрешность). Можно выбирать точки так, чтобы отрезок $[l; r]$ делился ими на $3$ равные части:
\[
    m_1 = l + \frac{r - l}{3},\quad m_2 = r - \frac{r - l}{3}.
\]

При этом каждый раз отрезок будет уменьшаться в $3 / 2$ раза. Однако, можно выбирать $m_1$ и $m_2$ очень близко друг к другу (и к середине отрезка), тогда каждый раз будем уменьшать отрезок почти в $2$ раза.

В случае целочисленного аргумента, отрезок $[l; r]$ становится дискретным, однако в силу отсутствия ограничений на выбор точек $m_1$ и $m_2$ корректность алгоритма не нарушается. Критерий остановки теперь --- $r - l < 3$, ведь в таком случае уже невозможно выбрать точки $m_1$ и $m_2$ удовлетворяли необходимому нам условию.

