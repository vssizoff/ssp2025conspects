\section{Кратчайшие пути}

\subsection{Алгоритм Дейкстры}

Пусть имеем взвешенный граф (все веса положительные!). Есть некоторая вершина, от которой мы хотим найти кратчайшие пути до всех остальных вершин с минимальным суммарным весом.

В начальной вершине мы точно знаем ответ --- $0$. Мы смотрим все соседние стартовой вершины и говорим, что туда мы точно можем добраться за вес соединяющего их ребра (изначально во всех вершинах стоит $+\infty$). Теперь выбираем вершину с наименьшим посчитанным на~этом этапе путём. Утверждается, что этот путь для неё действительно наименьший (не может уменьшиться при дальнейшем исполнении алгоритма). И из этой вершины обновляем все ответы, которые она может улучшить. Можно также сохранять ребро, которое последний раз обновило путь к~данной вершине (для построения дерева кратчайших путей).

Выбирать кратчайшую вершину можно полным перебором вершин. Тогда асимптотика составляет $O(n^2 + m)$. Эта версия алгоритма выгодна, если $m \sim n^2$ (много рёбер и много обновлений весов).

Можно пользоваться структурой данных по типу множества или приоритетной очереди для выбора ребра с минимальным весом и обновления весов (вот из-за этого работает медленно, если много рёбер). Тогда асимптотика составит $O(n\log n + m\log n)$.

\subsubsection{Реализация}

\noindent
Реализация без очереди за $O(n + m^2)$:

\begin{minted}[linenos, mathescape]{cpp}
// Список смежности графа (храним также вес ребра в вершину)
vector<vector<pair<int, int>>> adj;
vector<int> dist(n, INF), marks(n, 0);

dist[start] = 0;
for (int i = 0; i < n; ++i)
{
    int minn = INF, min_v = -1;
    for (int j = 0; j < n; ++j)
    {
        if (!marks[j] && dist[j] < minn)
            minn = dist[j], min_v = j;
    }
    marks[min_v] = 1;
    for (auto u : adj[min_v])
    {
        if (dist[u.first] > dist[min_v] + u.second)
            dist[u.first] = dist[min_v] + u.second;
    }
}

\end{minted}

\noindent
Реализация с очередью за $O(m\log m)$:

\begin{minted}[linenos, mathescape]{cpp}
vector<vector<pair<int, int>>> adj;
vector<int> dist(n, INF), marks(n, 0);

dist[start] = 0;

priority_queue<pair<int, int>> q;
for (int i = 0; i < n; ++i)
    // очередь с приоритетом в начале хранит максимум,
    // а нам нужен минимум, поэтому храним дистанцию
    // со знаком $\text{<<минус>>}$
    q.emplace(-dist[i], i);

while (!q.empty())
{
    int v;
    v = q.top().second;
    q.pop();
    if (!marks[v])
    {
        marks[v] = 1;
        for (auto u : adj[v])
        {
            if (dist[u.first] > dist[v] + u.second)
            {
                dist[u.first] = dist[v] + u.second;
                q.emplace(-dist[u.first], u.first);
            }
        }
    }
}
\end{minted}

\subsection{Алгоритм Форда "--- Беллмана}

Алгоритм позволяет находить кратчайшие пути в графах с отрицательными весами рёбер. Заметим, что мы работаем без отрицательных циклов (циклов с отрицательной суммой входящих в него рёбер). Ведь тогда можно бесконечно ходить по нему и уменьшать расстояние.

\begin{lemma} Если существует ребро $y \rightarrow x$ с весом $w(y, x)$, то выполняется \[\mathrm{dist}_x \leqslant \mathrm{dist}_y + w(y, x).\]
\end{lemma}

\begin{lemma}
    Если в пути есть цикл, то можем его отбросить (т.\,к. он только увеличивает суммарный вес). Следовательно кратчайший путь содержит не более $n - 1$ ребра, т.к. в нём нет повторяющихся вершин.
\end{lemma}

Изначально в стартовой вершине вес $0$, в остальных $+\infty$. Будем ходить по всем вершинам и обновлять расстояние по лемме 1. Утверждается, что после $i$-го обхода все кратчайшие пути, содержащие $i$ рёбер, будут определены. Тогда нам нужно совершить $n - 1$ обход и мы получим все кратчайшие пути.

\subsubsection{Реализация}

\begin{minted}[linenos, mathescape]{cpp}
// Список смежности графа (храним также вес ребра в вершину)
vector<vector<pair<int, int>>> adj;
vector<int> dist(n, INF);

dist[start] = 0;

for (int i = 0; i < n - 1; ++i)
{
    for (int v = 0; v < n; ++v)
    {
        for (auto u : adj[v])
            if(dist[u.first] > dist[v] + u.second)
                dist[u.first] = dist[v] + u.second;
    }
}
\end{minted}

Может показаться, что асимптотика алгоритма больше $O(n^2 \cdot m)$, но на самом деле весь внутренний цикл (идём по $v$) --- это $O(m)$. Таким образом, общая асимптотика $O(n^2 + n \cdot m)$.

Оптимизированная версия алгоритма Форда "--- Беллмана:

\begin{minted}[linenos, mathescape]{cpp}
// Список смежности графа (храним также вес ребра в вершину)
vector<vector<pair<int, int>>> adj;
vector<int> dist(n, INF);
bool any = 1;
int cnt = 0;

dist[start] = 0;

while (any && cnt < n)
{
    any = 0, cnt++;
    for (int v = 0; v < n; ++v)
    {
        for (auto u : adj[v])
            if (dist[u.first] > dist[v] + u.second)
            {
                dist[u.first] = dist[v] + u.second;
                any = 1;
            }
    }
}
\end{minted}

Теперь если мы ничего не обновили на каком-то этапе, то мы сразу выходим. Если мы что-то изменили на последней итерации, то у нас есть отрицательный цикл.

\subsection{Алгоритм Флойда "--- Уоршелла}

Здесь находим двумерный массив \texttt{dist[$i$][$j$]} размера $n \times n$, хранящий все расстояния между вершинами.

\begin{lemma}[Неравенство треугольника]
    $\mathrm{dist}_{i, j} \leqslant \mathrm{dist}_{i, k} + \mathrm{dist}_{k, j}$.
\end{lemma}

\begin{lemma}
    $\mathrm{dist}_{i, i} = 0$.
\end{lemma}

\begin{lemma}
    $\mathrm{dist}_{u, v} \leqslant w(u, v)$.
\end{lemma}

\subsubsection{Реализация}

\begin{minted}[linenos, mathescape]{cpp}
// Список смежности графа (храним также вес ребра в вершину)
vector<vector<int>> dist(n, vector<int>(n, INF));

for (int i = 0; i < m; ++i)
{
    cin >> u >> v >> w;
    // Выбираем наименьшее кратное ребро
    if (dits[u][v] > w)
        dist[u][v] = w;
}

for (int i = 0; i < n; ++i)
    dist[i][i] = 0;

for (int k = 0; k < n; ++k)
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            if (dist[i][j] > dist[i][k] + dist[k][j])
                dist[i][j] = dist[i][k] + dist[k][j];
\end{minted}

Приведём 2 схемы доказательства корректности алгоритма:

\begin{enumerate}
    \item \textbf{Индукция: } после $k$-го прохода имеем <<настоящие>> кратчайшие пути длины не более $k + 1$, содержащие как промежуточные только вершины $\{0, 1, \ldots, k\}$. Таким образом, через $n$ проходов мы получим все кратчайшие пути.
    \item \textbf{От противного:} пусть есть ненайденные пути. Из них возьмём кратчайший (по количеству входящих в него рёбер) $i\rightarrow j$, а на~нём возьмём вершину с максимальным номером $m$ ($m > \min\{i, j\}$, так как иначе этот путь точно найден). Тогда не найден один из~путей $i\rightarrow m$ или $m \rightarrow j$. Причём, оба этих пути короче $i \rightarrow j$. Противоречие, так как брали $i \rightarrow j$.
\end{enumerate}

Асимптотика составляет $O(n^3)$, но это куб с маленькой константой, ведь мы не используем почти никаких дополнительных структур данных (мы даже сам граф не храним, мы храним только матрицу \texttt{dist}). 

