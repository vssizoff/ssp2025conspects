\section{Обход в глубину}

\subsection{Идея обхода в глубину}

Из каждой вершины идём в любую свободную и красим её как посещённую. Идём так, пока есть непосещённые вершины. Если <<зашли в тупик>> (все соседние вершины покрашены), возвращаемся назад. Делаем так, пока все вершины не будут покрашенными. Асимптотика $O(n + m)$.

Пример простейшей задачи, которую можно решить с помощью обхода в глубину --- поиск числа компонент связности в графе. Для этого можно из каждой непосещённой вершины запускать обход в глубину, пока все вершины не будут посещены. Количество запусков, которое пришлось сделать, и есть число компонент.

\subsection{Реализация}

\begin{minted}[linenos, mathescape]{cpp}
// Вектор размера $n$ для раскраски посещённых вершин
vector<int> used;
// Список смежности графа $G$ размера $n$
vector<vector<int>> adj;

void dfs(int v)
{
    used[v] = 1; // отмечаем текущую вершину
    // обрабатываем текущую вершину, если нужно
    for (auto u : adj[v])
        if (!visited[u]) dfs(u);
}
\end{minted}

\subsection{Поиск циклов и покраска в три цвета}

\begin{problem}
    Найти цикл в данном графе.
\end{problem}

Ребро к посещённой вершине, не являющейся предком текущей при обходе в глубину, будем называть \textit{обратным}.

Ясно, что в данной компоненте связности графа есть цикл если и только если при обходе из какой-то вершины из этой компоненты мы нашли обратное ребро. Для восстановления ответа (т.\,е. для нахождения самого цикла) можно хранить массив предков и при нахождении обратного ребра с какой-то вершиной начинать подниматься по нему до того момента, как опять придём в эту же вершину.

Есть проблема --- такой способ не работает на ориентированных графах. В качестве простого контрпримера можно рассмотреть цикл на трёх вершинах с одним развёрнутым ребром. При рассмотрении этого примера видно, как решить проблему. Нам нужно отделять вершины, из которых мы уже вышли, от тех, которые ещё в обработке, для этого можно завести отдельный цвет.

\subsection{Ещё задачи}

\begin{definition}
    Граф называется \textit{двудольным}, если его вершины можно покрасить в два цвета так, чтобы ни одна пара вершин одного цвета не была соединена ребром.
\end{definition}

\begin{problem}
    Проверить данный граф на двудольность.
\end{problem}

Будем красить вершины в три цвета --- непосещённые и отдельно две доли. Если граф не связный, нужно проверить на двудольность каждую компоненту. Иначе начинаем обход из любой вершины и красим следующую вершину не в тот цвет, в который покрасили предыдущую.

\begin{problem}
    У профессора записаны все пары студентов, которые списывали или давали списывать. Требуется определить, сможет ли он разделить студентов на две группы так, чтобы любой обмен записками осуществлялся от студента одной группы студенту другой группы.
\end{problem}

По сути, задача заключается в проверке графа на двудольность с данными долями. 

\begin{problem}
    Дан связный граф, в котором $n$ вершин и $m$ ребер, требуется удалить наименьшее количество ребер так, чтобы получившийся граф стал деревом.
\end{problem}
