\section{Динамика по цифрам и профилю}
\subsection{Динамика по цифрам}
\begin{problem}
    Назовём хорошими числа, цифры в которых образуют неубывающую последовательность.
    Найти количество хороших чисел $\leq n$
\end{problem}
Пусть $dp[size][first]$ - количество хороших чисел длины $size$ начинающиеся с цифры $first$

\textbf{База:}

$$\forall d \in [0; 9]: dp[1][d] = 1$$

\textbf{Переход:}

$$dp[size][first] = \sum_{c = first}^9 dp[size - 1][c]$$

\begin{minted}[linenos, mathescape]{cpp}
int func(int p, int pf) {
    // p — текущая позиция (индекс в строке n)
    // pf — предыдущая цифра (или минимальная допустимая цифра для текущей позиции)
    // Т.е. текущая цифра должна быть >= pf
    int ans = 0;
    // Если мы поставим цифру < n[p], то остальные цифры можно выбрать любым "хорошим" способом
    for (int first = pf; first < n[p] - '0'; ++first) {
        ans += dp[n.size() - p][first];
    }
    // Теперь рассмотрим случай, когда ставим цифру == n[p]
    if (pf <= n[p] - '0' && p + 1 != n.size())
        ans += func(p + 1, n[p] - '0'); // Мы ещё не в последней позиции
    else if (pf <= n[p] - '0')
        ans++; // Мы на последней цифре, и n[p] >= pf — значит,
        // само число подходит
    return ans;
}
\end{minted}

\subsection{Динамика по профилю}

\begin{quote}
    ``Самое сложное ДП''
    \begin{flushright}
        - Сергей Сергеевич
    \end{flushright}
\end{quote}

\begin{problem}
    Дано поле $n \times m$ ($n \leq 10$ $m \leq 100$).
    Посчитать количество замощений плитками $1 \times 2$
\end{problem}

Предподсчитаем булевую функцию $f[mask1][mask2]$, которая обозначает возможность перехода от одного профиля $mask1$ к профилю $mask2$

$$
    f[mask1][mask2] =
    \begin{cases}
        1,&\text{если можно перейти},\\
        0,&\text{иначе}.
    \end{cases}
$$

Для удобства можно хранить профили в виде двоичных масок.
В качестве состояния динамики будем использовать профили размерами $n$.
В этом профиле 1 будет означать, что домино лежит горизонтально и заканчивается на этом столбце, иначе 0.
Таких профилей будет $2^n$.
Теперь проверим из какого профиля в какой можно перейти.
Из профиля $mask1$ в профиль $mask2$ можно перейти если выполняются условия:
\begin{itemize}
\item Можно положить горизонтальные домино.
    То есть там где в $mask2$ профиле стоит 1, в $mask1$ профиле должен стоять 0
\item Можно доложить в оставшиеся клетки вертикальные домино.
    То есть оставшиеся 0 в $mask1$ профиле должны образовывать четные подстроки.
\end{itemize}

\begin{center}
\begin{tikzpicture}
  % Creating the grid with a matrix of nodes
  \matrix[matrix of nodes, nodes={minimum size=0.8cm, anchor=center, text=black}] (m) {
    {} & 0 & 1 & {} \\
    {} & 0 & 0 & 1 \\
    {} & 0 & 0 & {} \\
    0 & 1 & 0 & {} \\
  };

  % Adding the text label above the grid
  \node[above=0.1cm of m] {mask1 mask2};

  % Drawing teal rectangles for the grouped cells
  % Horizontal
  \node[fit=(m-1-2) (m-1-3), draw=red, inner sep=0pt, line width=1.5pt] {};
  \node[fit=(m-2-3) (m-2-4), draw=green, inner sep=0pt, line width=1.5pt] {};
  \node[fit=(m-4-1) (m-4-2), draw=blue, inner sep=0pt, line width=1.5pt] {};
  % Vertical
  \node[fit=(m-2-2) (m-3-2), draw=teal, inner sep=0pt, line width=1.5pt] {};
  \node[fit=(m-3-3) (m-4-3), draw=magenta, inner sep=0pt, line width=1.5pt] {};
\end{tikzpicture}
\end{center}

\begin{minted}[linenos, mathescape]{cpp}
bool check(int mask1, int mask2) {
    bool even0 = false; // нечётность количества нулей (до $i$)
    for (int i = 0; i < n; i++) {
        if ((mask1 & (1 << i)) && (mask2 & (1 << i)))
            return false; // если доминошка заканчивается
            // в $i$ координате в обоих профилях
        if ((mask1 & (1 << i)) && even0)
            return false;//если в первом профиле в $i$ координате доминошка
            // закончилась, а до неё нечётное кол-во нулей подряд
        if ((mask2 & (1 << i)) && even0)
            return false;//если во втором профиле в $i$ координате доминошка
            // закончилась, а до неё нечётное кол-во нулей подряд
            // (то есть горизонтальная доминошка не может начаться)
        if ((mask1 & (1 << i)) || (mask2 & (1 << i))) even0 = false;
        else even0 = !even0;
    }
    return !even0;
}

std::vector f(1 << n, std::vector<bool>(1 << n));
for (int mask1 = 0; mask1 < (1 << n); mask1++) {
    for (int mask2 = 0; mask2 < (1 << n); mask2++) {
        f[mask1][mask2] = check(mask1, mask2);
    }
}
\end{minted}

Пусть $dp[i][mask]$ - количество вариантов заполнить первые $i$ столбцов с $mask$ в $i + 1$ столбце

\textbf{База:}

$$dp[0][0] = 1$$

$$\forall mask \in [{1;2^n}): dp[0][mask] = 0$$

\textbf{Переход:}

$$dp[i][mask] = \sum_{\substack{mask2 = 0 \\ f[mask2][mask] = 1}}^{2^n - 1} dp[i - 1][mask2]$$

\textbf{Ответ:}

$$\sum_{mask} dp[m - 1][mask]$$
где mask - все маски без подпоследовательностей из нулей нечётной длины

\begin{minted}[linenos, mathescape]{cpp}
std::vector dp(m, std::vector<long long>(1 << n));
dp[0][0] = 1;
for (int i = 1; i < m; ++i) {
    for (int mask = 0; mask < (1 << n); ++mask) {
        for (int mask2 = 0; mask2 < (1 << n); ++mask2) {
            if (f[mask2][mask]) dp[i][mask] += dp[i - 1][mask2];
            // если можем перейти от $mask2$ к $mask$, то прибавляем
        }
    }
}
long long ans = 0;
for (int mask = 0; mask < (1 << n); ++mask) { // считаем ответ
    bool even0 = false, containsEvenSequences = false;
    for (int i = 0; i < n; ++i) { // проверка на наличае
        // подпоследовательностей из нулей нечётной длины
        if (!(mask & (1 << i))) {
            even0 = !even0;
            continue;
        }
        if (even0) {
            containsEvenSequences = true;
            break;
        }
    }
    if (containsEvenSequences || even0) continue; // если нашли или
    // заканчивается нечетным количеством нулей
    ans += dp[m - 1][mask];
}
cout << ans;
\end{minted}

\begin{problem}

\end{problem}